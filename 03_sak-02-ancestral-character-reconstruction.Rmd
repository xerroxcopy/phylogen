---
title: "R Notebook"
output: html_notebook
---

# continuous ancestral phenotype reconstruction using fastAnc

filter out obsolete products and leave models available in 2016

would NJ reconstruct ancestral state better than UPGMA without OLD data?

```{r}
df_sak_modern <- df_sak |> 
  filter(!str_detect(short_name, pattern = "OLD")) |> 
  filter(!str_detect(short_name, pattern = "OUT")) |> 
  select(-node) |> # this node column is from old rowid so delete it
  rowid_to_column(var = "node") |> # and reassign the id again
  mutate(node = node |> as.integer()) 

# View(df_sak_modern)
# filter only 0/1 categorical variables
df_sak_factor_modern <-
  df_sak_modern |> 
  select(Layer1:`MAT_Scale:IsMetalGroup`) |> 
  select(where(~(sum(.) > 0  & sum(.) < nrow(df_sak_modern)))) |> 
  mutate(across(everything(), as.factor)) 
```

# distance: modern

hammingdists is too buggy so changing to hamming.distance in e1071
```{r}
sak_dist_modern <- 
  hamming.distance(df_sak_factor_modern |>as.matrix()) |> 
  as.dist()
```

but e1071's hamming.distance is also buggy...? i always have to compute sak_dist_modern and then nj()

```{r}
# do not run this!
# sak_dist_modern <- 
#   hamming.distance(df_sak_factor_modern |>as.matrix()) |>
#   as.dist()
# sak_dist_modern |> nj() |> plot() # right after computing distance. works
# sak_dist_modern |> nj() |> plot() # second time. does not work
# sak_dist_modern <- 
#   hamming.distance(df_sak_factor_modern |>as.matrix()) |>
#   as.dist()
# sak_dist_modern |> nj() |> plot() # second time, but right after computing distance. works

```

## construct UPGMA and NJ trees

### UPGMA

```{r fig.width = 5, fig.height = 5}
sak_dist_modern <- 
  hamming.distance(df_sak_factor_modern |>as.matrix()) |>
  as.dist()
sak_upgma_modern <- sak_dist_modern |>
  hclust(method = "average") |> # average = UPGMA
   as.phylo()
df_sak_upgma_modern <- sak_upgma_modern |>
  as_tibble() |> 
  left_join(df_sak_modern, by = "node") |> 
  select(parent:class, short_name, Functions, width, weight) |> 
    mutate(short_name = if_else(is.na(short_name), node |> as.character(), short_name)) |> 
 column_to_rownames(var = "short_name") |> 
  mutate(node = node |> as.numeric()) |> 
  select(node, class, Functions, weight, width)
sak_upgma_modern$tip.label <- df_sak_modern$short_name
sak_upgma_modern |> plot(type = "u")
```


### NJ

```{r fig.width = 8, fig.height = 8}
sak_dist_modern <- 
  hamming.distance(df_sak_factor_modern |>as.matrix()) |>
  as.dist()
sak_nj_modern <- sak_dist_modern |> 
  nj() 
sak_nj_modern$tip.label <- df_sak_modern$short_name
df_sak_nj_modern <- 
  sak_nj_modern |> 
  as_tibble() |>
  left_join(df_sak_modern, by = "node") |>
  select(parent:class, short_name, Functions, width, weight) |> 
  mutate(short_name = if_else(is.na(short_name), node |> as.character(), short_name)) |> 
  column_to_rownames(var = "short_name") |> 
  mutate(node = node |> as.numeric()) |> 
  select(node, class, Functions, weight, width)
sak_nj_modern2 <- full_join(sak_nj_modern, df_sak_nj_modern, by = "node")
# quick plot just to check the data is prob  correct


sak_nj_modern2 |> 
    ggtree(layout = "ape", aes(colour = weight)) +
  geom_tiplab(aes(label = paste0(class, label),), family = "Fira Code", size = 3, hjust = -.3) + # model name (e.g., Explorer)
  geom_tiplab(aes(label = weight |> round(0)), family = "Fira Code", size = 2, hjust = 1) + # weight of models
  geom_nodelab(aes(label = weight |> round(0)), family = "Fira Code", size = 2, vjust = 1) + # estimated weights at nodes
  geom_treescale() + 
  scale_size_area(max_size = 5) +
  scale_colour_viridis_c(limits = c(15, 206)) +
  coord_cartesian(clip = 'off') +
  theme_tree(
    plot.margin=margin(120, 40, 40, 40), 
  ) +
  theme(
    legend.position = c(.1, .9),
    legend.key.size = unit(2, 'mm'),
    ) 
```



## root [obsolete]

NJについてはrootしたバージョンでfastAncをしたいので、まずRootをつける・・・と思っていたが、Rootをつけるところで恣意的にできてしまって中立な感じではないので、アルゴリズムにまかせてしまったほうがよい気がしてきた…とりあえずコードは遺しておく。

どこにつけるのがよいか？

#### show node numbers

```{r fig.width = 5, fig.height = 5}
sak_nj |> 
  ggtree(layout = "ape") +
  geom_tiplab() +
  geom_nodelab(aes(label = node), colour = "red", size = 2)
```

```{r fig.width = 5, fig.height = 5}
sak_nj_modern |> 
  ggtree(layout = "ape") +
  geom_tiplab() +
  geom_nodelab(aes(label = node), colour = "red", size = 2)
```

一緒にプロットするとPioneerやFarmerのあたりだが、その情報がなければ中央付近、つまり71がよさそう

#### root

```{r}
sak_nj_rooted <- sak_nj |> 
  root(outgroup = 40) # root the NJ tree so that it compares to UPGMA nicely
sak_nj_rooted$root.edge <- 0
sak_nj_rooted |> plot()
```
# phytools fastAnc

```{r}
## kyoutsuu 

#### kyoutsuu: modern, outgroup, old, everything
df_sak_named_rows <- df_sak |> 
  column_to_rownames(var = "short_name")
df_sak_named_rows_modern <- df_sak_modern |> 
  column_to_rownames(var = "short_name")
```


since fastAnc does not work, try the minimum version

```{r}
# 
# sak_nj |> 
#   ggtree(layout = "ape") +
#   geom_tiplab()
# sak_trait_weight <- df_sak_named_rows |> 
#   select(class) |> 
#   as.matrix()
# sak_trait_weight_named_num <- sak_trait_weight[, 1][1:nrow(df_sak_named_rows)]
# 
# 
# sak_trait_weight_named_num
# test <-  sak_dist |> 
#   nj()
# sak_fit_upgma_weight <- fastAnc(
#   tree = sak_nj,
#   x = sak_trait_weight_named_num)
# View(sak_fit_upgma_weight)
```


```{r}
# create a named number vector of weights (in gram) of SAKs
sak_trait_weight <- df_sak_named_rows |> 
  select(weight) |> 
  as.matrix()
sak_trait_width <- df_sak_named_rows |> 
  select(width) |> 
  as.matrix()
sak_trait_class <- df_sak_named_rows |> 
  select(class) |> 
  as.matrix()
sak_trait_function <- df_sak_named_rows |> 
  select(Functions) |> 
  as.matrix()
# change the matrix into a vector, then cull unwanted nodes after 57
sak_trait_weight_named_num <- sak_trait_weight[, 1][1:nrow(df_sak_named_rows)]
sak_trait_width_named_num <- sak_trait_width[, 1][1:nrow(df_sak_named_rows)]
sak_trait_class_named_num <- sak_trait_class[, 1][1:nrow(df_sak_named_rows)]
sak_trait_function_named_num <- sak_trait_function[, 1][1:nrow(df_sak_named_rows)]

#### kyoutsuu: modern

# create a named number vector of weights (in gram) of SAKs
sak_trait_weight_modern <- df_sak_named_rows_modern |> 
  select(weight) |> 
  as.matrix()
sak_trait_width_modern <- df_sak_named_rows_modern |> 
  select(width) |> 
  as.matrix()
sak_trait_class_modern <- df_sak_named_rows_modern |> 
  select(class) |> 
  as.matrix()
sak_trait_function_modern <- df_sak_named_rows_modern |> 
  select(Functions) |> 
  as.matrix()
# change the matrix into a vector, then cull unwanted nodes after 57
sak_trait_weight_modern_named_num <- sak_trait_weight_modern[, 1][1:nrow(df_sak_named_rows_modern)]
sak_trait_width_modern_named_num <- sak_trait_width_modern[, 1][1:nrow(df_sak_named_rows_modern)]
sak_trait_class_modern_named_num <- sak_trait_class_modern[, 1][1:nrow(df_sak_named_rows_modern)]
sak_trait_function_modern_named_num <- sak_trait_function_modern[, 1][1:nrow(df_sak_named_rows_modern)]
```


```{r}
## UPGMA
# now fit the data to nodes using UPGMA tree. dunno how to vectorize them so i just iterate it over weight, class, width, and function.
#### modern, outgroup, old, everything
sak_fit_upgma_weight <- fastAnc(
  sak_upgma, 
  sak_trait_weight_named_num,
  )

df_sak_upgma$weight[(nrow(df_sak_named_rows) + 1):nrow(df_sak_upgma)] <- sak_fit_upgma_weight

sak_fit_upgma_width <- fastAnc(
  sak_upgma, 
  sak_trait_width_named_num,
   
  )
df_sak_upgma$width[(nrow(df_sak_named_rows) + 1):nrow(df_sak_upgma)] <- sak_fit_upgma_width

sak_fit_upgma_class <- fastAnc(
  sak_upgma, 
  sak_trait_class_named_num,
   
  )
df_sak_upgma$class[(nrow(df_sak_named_rows) + 1):nrow(df_sak_upgma)] <- sak_fit_upgma_class

sak_fit_upgma_function <- fastAnc(
  sak_upgma, 
  sak_trait_function_named_num,
   
  )
df_sak_upgma$Functions[(nrow(df_sak_named_rows) + 1):nrow(df_sak_upgma)] <- sak_fit_upgma_function

#### UPGMA: modern

sak_fit_upgma_weight_modern <- fastAnc(
  sak_upgma_modern, 
  sak_trait_weight_modern_named_num,

  )
df_sak_upgma_modern$weight[(nrow(df_sak_named_rows_modern) + 1):nrow(df_sak_upgma_modern)] <- sak_fit_upgma_weight_modern

sak_fit_upgma_width_modern <- fastAnc(
  sak_upgma_modern, 
  sak_trait_width_modern_named_num,
  )
df_sak_upgma_modern$width[(nrow(df_sak_named_rows_modern) + 1):nrow(df_sak_upgma_modern)] <- sak_fit_upgma_width_modern

sak_fit_upgma_class_modern <- fastAnc(
  sak_upgma_modern, 
  sak_trait_class_modern_named_num,
   
  )
df_sak_upgma_modern$class[(nrow(df_sak_named_rows_modern) + 1):nrow(df_sak_upgma_modern)] <- sak_fit_upgma_class_modern

sak_fit_upgma_function_modern <- fastAnc(
  sak_upgma_modern, 
  sak_trait_function_modern_named_num,
   
  )
df_sak_upgma_modern$Functions[(nrow(df_sak_named_rows_modern) + 1):nrow(df_sak_upgma_modern)] <- sak_fit_upgma_function_modern

### NJ
#### NJ modern, outgroup, old, everything. rooted

sak_fit_nj_weight <- fastAnc(
  sak_nj_rooted, 
  sak_trait_weight_named_num,
   
  )
df_sak_nj$weight[(nrow(df_sak_named_rows) + 1):nrow(df_sak_nj)] <- sak_fit_nj_weight

# fill NA (Officer, which I couldn't find ANY width data anywhere...)
sak_trait_width_named_num[is.na(sak_trait_width_named_num)] <- 20.5 # borrow from old soldier knife
sak_fit_nj_width <- fastAnc(
  sak_nj_rooted, 
  sak_trait_width_named_num,
   
  )
df_sak_nj$width[(nrow(df_sak_named_rows) + 1):nrow(df_sak_nj)] <- sak_fit_nj_width

sak_fit_nj_class <- fastAnc(
  sak_nj_rooted, 
  sak_trait_class_named_num,
   
  )
df_sak_nj$class[(nrow(df_sak_named_rows) + 1):nrow(df_sak_nj)] <- sak_fit_nj_class

sak_fit_nj_function <- fastAnc(
  sak_nj_rooted, 
  sak_trait_function_named_num,
  )
df_sak_nj$Functions[(nrow(df_sak_named_rows) + 1):nrow(df_sak_nj)] <- sak_fit_nj_function

#### NJ modern

sak_fit_nj_weight_modern <- fastAnc(
  sak_nj_modern, 
  sak_trait_weight_modern_named_num,
   
  )
df_sak_nj_modern$weight[(nrow(df_sak_named_rows_modern) + 1):nrow(df_sak_nj_modern)] <- sak_fit_nj_weight_modern

sak_fit_nj_width_modern <- fastAnc(
  sak_nj_modern, 
  sak_trait_width_modern_named_num,
   
  )
df_sak_nj_modern$width[(nrow(df_sak_named_rows_modern) + 1):nrow(df_sak_nj_modern)] <- sak_fit_nj_width_modern

sak_fit_nj_class_modern <- fastAnc(
  sak_nj_modern, 
  sak_trait_class_modern_named_num,
   
  )
df_sak_nj_modern$class[(nrow(df_sak_named_rows_modern) + 1):nrow(df_sak_nj_modern)] <- sak_fit_nj_class_modern

sak_fit_nj_function_modern <- fastAnc(
  sak_nj_modern, 
  sak_trait_function_modern_named_num,
   
  )
df_sak_nj_modern$Functions[(nrow(df_sak_named_rows_modern) + 1):nrow(df_sak_nj_modern)] <- sak_fit_nj_function_modern
```

check

is `df_sak_nj_modern` ok? `NaN` included?
```{r}
View(df_sak_upgma) # for main tree plot
View(df_sak_nj) # for main tree plot
View(df_sak_upgma_modern) # for 2 by 3 phenogram plot
View(df_sak_nj_modern) # for 2 by 3 phenogram plot
```



# plot

for modern ones and estimating the ancestors, go to sak-03-ancestral-plot.Rmd
for all model, go to sak-04-all-model-plot.Rmd

# categorical





## ancestral states (sequence) reconstruction

基本的には{phangorn}のParsimonyを使う方針でいく。本当はもっといい方法があるのかもしれないけど。
https://rstudio-pubs-static.s3.amazonaws.com/345955_fba1ccbdcd8f424aa5505c15bfd75bf7.html これも使えるかも pratchet ちゃんとよんでない


#### phangorn Parsimony

phyDat化でdim()が70になっちゃうのはas.character()で回復できる。が、anc.mprはphyDatではない？ので回復できない。purrrのmapなどでmatrixをvectorにすることでできそう。やってない。

```{r}
phyDat_sak_modern <-
 df_sak_factor_modern |> 
  mutate(name = df_sak_modern$short_name) |> 
  relocate(name) |> 
  rownames_to_column() |> 
  pivot_longer(-name, 'variable', 'value') |> 
  pivot_wider(variable, name) |> 
  filter(variable != "rowname") |> 
  mutate(across(everything(), as.character)) |> 
  column_to_rownames(var = "variable") |>
  phyDat(type = "USER", levels = c("1", "0"), return.index = FALSE) 
phyDat_sak_modern |> as.character()
sak_acctran <- acctran(tree = sak_nj_modern, data = phyDat_sak_modern)

sak_acctran |> 
  parsimony(phyDat_sak)
anc.acctran <- ancestral.pars(sak_acctran, phyDat_sak_modern, "ACCTRAN")
anc.mpr <- ancestral.pars(sak_acctran, phyDat_sak_modern, "MPR")
anc.acctran |> View()
anc.mpr |> View()
plotAnc(sak_acctran, anc.mpr, 14)
anc.mpr$`83`
a_model_name <- "Classic.AL"
a_model_matrix <- anc.mpr[[a_model_name]]
a_model_factor <- df_sak_modern |> 
  filter(short_name == a_model_name) |> unlist(use.names = FALSE)
a_model_factor_min <- a_model_factor[7:95] |> as.numeric()  
a_model_factor_min |> length() # len 89
# 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
# 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1
# 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1
phyDat_sak_modern |> image()
allSitePattern(5, levels = c("a", "c", "g", "t"), names = NULL) |> View()
anc.mpr$Classic.AL[, 1] 
df_sak_factor_modern[,15:25] |> View()
phyDat_sak_modern$Classic.AL |> length() # 70. does phyDat() drop uninformative traits?
df_sak_factor_modern_min <- df_sak_factor_modern |> 
  mutate(across(everything(), as.character )) |>
  mutate(across(everything(), as.numeric)) |>
  select(where(~sum(.) > 1)) |> 
  select(where(~sum(.) < nrow(df_sak))) # |> 
  mutate(short_name = df_sak_modern$short_name) |> 
  relocate(short_name)
df_sak_factor_modern_min[2,] |> unlist(use.names = FALSE)
phyDat_sak_modern |> removeUndeterminedSites()
phyDat_sak_modern |> View()
```

nodeの位置を確認

```{r fig.width = 6, fig.height = 6}
sak_nj2 |> 
  ggtree(layout = "ape") +
  geom_tiplab(aes(label = paste0(class, label),), family = "Fira Code", size = 3, hjust = -.3) + # model name (e.g., Explorer)
  geom_nodelab(aes(label = node), family = "Fira Code", size = 2) + 
  geom_tippoint() # 99, nearest = farmer

# Farmerのいるあたりはどこ？

sak_nj_modern2 |> 
  ggtree(layout = "ape") +
  geom_tiplab(aes(label = paste0(class, label),), family = "Fira Code", size = 3, hjust = -.3) + # model name (e.g., Explorer)
  geom_nodelab(aes(label = node), colour = "red", family = "Fira Code", size = 2) +
  geom_tippoint() # 82 or 84, near farmer cadet pioneer

sak_upgma2 |> 
    ggtree(layout = "ape") +
  geom_tiplab(aes(label = paste0(class, label),), family = "Fira Code", size = 3, hjust = -.3) + # model name (e.g., Explorer)
  geom_nodelab(aes(label = node), family = "Fira Code", size = 2) + 
  geom_tippoint() # 71, nearest = Cadet pioneer Farmerの根本。Soldier 1961はFarmerとくまされている
sak_upgma_modern |> 
  ggtree(layout = "ape") +
  geom_tiplab(aes(label = label), family = "Fira Code", size = 3, hjust = -.3) + # model name (e.g., Explorer)
  geom_nodelab(aes(label = node), colour = "red", family = "Fira Code", size = 2) +
  geom_tippoint() +# 82 or 84, near farmer cadet pioneer +
  coord_cartesian(clip = 'off') +
  theme_tree(
    plot.margin=margin(120, 40, 40, 40), 
  )
```



<https://www.phytools.org/eqg2015/asr.html> "discrete characters"は微妙。ひとつの形質に関して図示。これを何回も繰り返すべきなのかもしれないが。


#### phangorn ML
[phangorn](https://cran.r-project.org/web/packages/phangorn/vignettes/Ancestral.html)を使ってみるか？ATGCでなくてもできるとよいのだが。→MLだと少なくともシーケンスじゃないとダメかなぁ。
```{r}
# fit_sak_nj <- fastAnc(tree = sak_nj, x = phyDat_sak,  )
fit_sak_nj <- pml(tree = sak_nj, data = phyDat_sak) |> 
  optim.pml() # ... :D
```



RRPhyloのほうがいいのか？


#### ace

それとも[ace](https://rdrr.io/cran/ape/man/ace.html)なのか？

```{r}
sak_nj_rooted <- sak_nj |>
  # root(outgroup = 40) |> 
  multi2di() # to make it dichotomous as ace() requires
# sak_nj_rooted$root.edge <- 0 # https://rdrr.io/cran/ape/man/root.html Examples
ace(x = phyDat_sak, 
    phy = sak_nj_rooted, # OLD.Soldier.1891
    type = "discrete")
```

#### rerootingMethod

それとも[phyTools](http://blog.phytools.org/2015/06/update-to-rerootingmethod-for-ancestral.html)の`rerootingMethod()`なのか？→これは

> then rownames should be species names, column names should be states for the discrete character, and rows of the matrix should sum to 1.0.

とあるのでダメかな
```{r}
rerootingMethod(sak_nj, x = phyDat_sak, model = "ER")
```
