---
title: "R Notebook"
output: html_notebook
---

# sak

```{r}
df_sak <- data_sak_raw |> 
  mutate(id = paste0(class, short_name)) |> 
  filter(short_name != "OUT.Buck") |> 
  # filter(short_name != "OUT.Buck") |> 
  mutate(layer_category = case_when(
    Layers == 1 ~ "Layer1",
    Layers == 2 ~ "Layers2",
    Layers == 3 ~ "Layers3",
    Layers == 4 ~ "Layers4",
    Layers > 4 ~ "LayersMoreThan4"
    ),
    value = 1L
  ) |>
  pivot_wider(names_from = layer_category, values_from =value, values_fill = 0L) |> 
  relocate(starts_with("Layer"), .before = Lock) |> 
  relocate("Layer1", .after = "Layers") |> 
  select(-sak)　 |> 
  rowid_to_column(var = "node") |> 
  mutate(node = node |> as.integer())
```
## corresp

data <https://www1.doshisha.ac.jp/~mjin/R/Chap_26/26.html> use FactoMineR instead of MASS to get eigen values

```{r fig.width=5, figh.height = 3}

df_sak_factor <- df_sak |> 
  # filter(Price ) |> # remove swissChampXAVT
  select(Layer1:`MAT_Scale:BrassWood`) |> 
  mutate(across(everything(), as.factor))
sak_mca <- MCA(df_sak_factor, ncp = 2, graph = FALSE)

df_sak_mca_coord <- sak_mca$ind$coord |> 
  as_tibble() |> 
  transmute(mca_x = `Dim 1`, mca_y = `Dim 2`)


# http://www.sthda.com/english/articles/31-principal-component-methods-in-r-practical-guide/114-mca-multiple-correspondence-analysis-in-r-essentials/
# extract eigen value
sak_corresp_eigen_values <- get_eigenvalue(sak_mca)
# check eigen v
fviz_screeplot(sak_mca, addlabels = TRUE, ylim = c(0, 20))

# variance explained by dim1 and dim2 are:
# they are later used in the ggplot
sak_corresp_dim1_ev <- sak_corresp_eigen_values[1, 2]
sak_corresp_dim2_ev <- sak_corresp_eigen_values[2, 2]

# coordinates
df_sak_factor2 <- bind_cols(df_sak, df_sak_mca_coord)

```

#### plot all corresp

```{r}
df_sak_factor2 |>
  ggplot(aes(-mca_x, mca_y, label = short_name, colour = weight)) +
  # geom_point(data = df_sak_factor2 |> select(-class), colour = "grey70") +
  geom_text(aes(label = class),
            family = "Alte DIN 1451 Mittelschrift",
            fontface = "bold"
            ) +
  geom_text_repel(
    # force = .3,
    force_pull = 2,
    max.overlaps = 30, 
    max.time = 3, 
    max.iter = 3e5, 
    size = 1.5,
    min.segment.length = .1, 
    family = "Fira Code",
    segment.colour = NA
    
    ) +
  scale_colour_viridis_c(trans = "log10") +
  scale_size_area() +
  # labs(colour = "Price (1k yen)" ) +
  xlab(paste0("Dimension 1 (", sak_corresp_dim1_ev |> round(digits = 1), "%)")) +
  ylab(paste0("Dimension 2 (", sak_corresp_dim2_ev |> round(digits = 1), "%)")) +
  theme_bw(base_family = "Fira Code") +
  theme(panel.background = element_rect(fill = "white", colour = "black")) +
  guides(colour = guide_colourbar(barwidth = 5, barheight = .5), direction = "horizontal") +
  theme(legend.direction = "horizontal", legend.position = c(0.2, 0.9),
        panel.grid = element_blank())


ggsave(filename = "output/sak_correspXY_all.pdf", 
         device = cairo_pdf,
         dpi = 300,
         unit = "mm",
       height = 100, 
       width = 166, 
       limitsize = FALSE)
```

cut the trees

<https://uc-r.github.io/hc_clustering>

```{r}
df_fviz_wss <- df_sak_factor |> 
  fviz_nbclust(FUN = hcut, method = "wss", k.max = 30)

df_fviz_wss2 <- df_fviz_wss$data |> 
  mutate(clusters = as.numeric(clusters))
plot_sak_elbow <- df_fviz_wss2 |>   
  ggplot(aes(clusters, y)) +
  geom_line() +
  # geom_point() +
  ylab("Total WSS") +
  xlab("No of clusters k") +
  theme_classic(base_family = "Fira Code")

# silhouette
fviz_sil <- df_sak_factor |> 
  fviz_nbclust(FUN = hcut, method = "silhouette", k.max = 30)
df_fviz_sil <- fviz_sil$data |> 
  mutate(clusters = as.numeric(clusters))
# check optimal cluster size
fviz_sil
```


```{r}
plot_sak_sil <- df_fviz_sil |>   
  ggplot(aes(clusters, y)) +
  geom_line() +
  geom_vline(xintercept = 4, linetype = "dashed", colour = "gray90") +
  ylab("Avg sil width") +
  xlab("No of clusters k") +
  theme_classic(base_family = "Fira Code")
# cowplot
plot_grid(plot_sak_elbow, plot_sak_sil, 
          align = "hv",
          ncol=2, 
          labels=LETTERS)
ggsave(filename = "output/sak_sil_elbow.pdf", 
       device = cairo_pdf,
       dpi = 200,
       unit = "mm",
       height = 60, # pixelsでのサイズ
       width = 150,  # pixelsでのサイズ
       limitsize = FALSE)

```

## UPGMA

### hamming

SplitsTree4のUncorrectedPがHamming距離である。、{e1071}の`hamming.distance()`をつかう。`hammingdists()`はダメ

```{r}
sak_dist <- hamming.distance(df_sak_factor |> as.matrix()) |> as.dist()

sak_upgma <- sak_dist |>
  hclust(method = "average") |> # average = UPGMA
   as.phylo()
sak_upgma |> 
  plot.phylo(type = "u", use.edge.length = TRUE, lab4ut = "axial")
```

## NJ

```{r}
sak_nj <- sak_dist |> nj()
sak_nj$tip.label <- df_sak$short_name
sak_nj |> 
  plot.phylo(type = "u", use.edge.length = TRUE, lab4ut = "axial")
```

## join traits

### UPGMA

```{r}
df_sak_upgma <- sak_upgma |>
  as_tibble() |> 
  left_join(df_sak_rowid, by = "node") |> 
  select(parent:class, short_name, Functions, width, weight, id) |> 
    mutate(short_name = if_else(is.na(short_name), node |> as.character(), short_name)) |> 
 column_to_rownames(var = "short_name") |> 
  mutate(node = node |> as.numeric()) |> 
  select(node, class, id, Functions, weight, width) # temporarily limite
sak_upgma$tip.label <- df_sak$short_name
```

### NJ

```{r}
df_sak_nj <- sak_nj |> 
  as_tibble() |> 
  left_join(df_sak_rowid, by = "node") |> 
  select(parent:class, short_name, Functions, width, weight, id) |> 
  mutate(short_name = if_else(is.na(short_name), node |> as.character(), short_name)) |> 
  column_to_rownames(var = "short_name") |> 
  mutate(node = node |> as.numeric()) |> 
  select(node, class, id, Functions, weight, width)
```


## join tree with df for plot

```{r}
# join with tree. seems impossible but possible :D
sak_upgma2 <- full_join(sak_upgma, df_sak_upgma, by = "node")
sak_nj2 <- full_join(sak_nj, df_sak_nj, by = "node")
```


# appendices

参考。phyDatでカテゴリカルなものを復元しようとしたり


create phyDat data for categorical phenotype reconstruction

```{r}
phyDat_sak <-
 df_sak_factor |> 
  mutate(name = df_sak$short_name) |> 
  relocate(name) |> 
  rownames_to_column() |> 
  pivot_longer(-name, 'variable', 'value') |> 
  pivot_wider(variable, name) |> 
  filter(variable != "rowname") |> 
  mutate(across(everything(), as.character)) |> 
  column_to_rownames(var = "variable") |>
  phyDat(type = "USER", levels = c("0", "1")) 
```

### neighbornet

できるけど…

plot isn't really good and does not match exactly with SplitsTree4 output, probably because `neighborNet()` func is experimental. use SplitsTree4 using write.nexus()?

```{r fig.width = 5, fig.height=5}
sak_dist2 <- phyDat_sak |> dist.hamming() # must be phyDat
sak_nn <- sak_dist2 |> 
  neighborNet() # takes 30sec



df_sak_nn <- sak_nn |> 
  as_tibble() |> 
  left_join(df_sak_rowid, by = "node") |> 
  select(parent:class, short_name, Functions, width, weight, id) |> 
  rowid_to_column() |> 
  mutate(short_name = if_else(is.na(short_name), rowid |> as.character(), short_name)) |> 
  column_to_rownames(var = "short_name") |>
  mutate(node = node |> as.numeric()) |>
  select(node, class, id, Functions, weight, width)
sak_nn2 <- full_join(sak_nn, df_sak_nn, by = "node")
```

### plot NN

```{r}
sak_nn |>  ggsplitnet(aes(x, y))+
  geom_splitnet(size = .1) +
  geom_tiplab2(size = 2, family = "Fira Code", hjust = -.1) +
  theme_tree() +
  ggexpand(.1) + 
  ggexpand(.1, direction=-1)
ggsave(filename = "output/sak_nn.pdf", 
       device = cairo_pdf,
       dpi = 450,
       unit = "mm",
       height = 360, # pixelsでのサイズ
       width = 360,  # pixelsでのサイズ
       limitsize = FALSE)
```

networx()ではかなりできることが少ないので、SplitsTree4を使わないといけなさそう：

```{r fig.width = 5, fig.height=5}
getwd()
df_sak_factor_with_name |> 
  write_tsv("./data/sak_factor_for_mesquite_nex.tsv")
sak_nj |> write.nexus("data/sak_factor.nex")
```

```{r}
# data(yeast, package="phangorn")
# dm <- phangorn::dist.ml(yeast)
# nnet <- phangorn::neighborNet(dm)

```

## Delta Score

{phangorn} provides `delta.score()`. [document](https://rdrr.io/cran/phangorn/man/delta.score.html) ##\# example

デルタスコア計算できるのはいいけど、ネットワークの形がSplitsTree4と違うので参考程度にしかならないか。

```{r}
data(yeast)
hist(delta.score(yeast, "all"))
```

```{r}
# compute delta score. takes 1min, sometimes it fails with error object 'decreasing' not found
# re-run it and it works (at least it worked)
sak_delta_all <- phyDat_sak |> delta.score(arg = "all") 


sak_delta_all |> 
  hist()
mean(sak_delta_all) # identical to delta.score()
length(sak_delta_all)


```




